#include "includes.h"
/***********************************************************
By Huahua Wang, the University of Minnesota, twin cities
***********************************************************/












__global__ void reduce(float *g_idata, float *g_odata, unsigned int n)
{
extern __shared__ float sdata[];

// perform first level of reduction,
// reading from global memory, writing to shared memory
unsigned int tid = threadIdx.x;
unsigned int i = blockIdx.x*blockDim.x*2 + threadIdx.x;
unsigned int gridSize = blockDim.x*2*gridDim.x;

float mySum = 0;

// we reduce multiple elements per thread.  The number is determined by the
// number of active thread blocks (via gridDim).  More blocks will result
// in a larger gridSize and therefore fewer elements per thread
while (i < n)
{
mySum += g_idata[i];
// ensure we don't read out of bounds
if (i + blockDim.x < n)
mySum += g_idata[i+blockDim.x];
i += gridSize;
}

// each thread puts its local sum into shared memory
sdata[tid] = mySum;
__syncthreads();


// do reduction in shared mem
if (blockDim.x >= 1024) { if (tid < 512) { sdata[tid] = mySum = mySum + sdata[tid + 512]; } __syncthreads(); }
if (blockDim.x >= 512) { if (tid < 256) { sdata[tid] = mySum = mySum + sdata[tid + 256]; } __syncthreads(); }
if (blockDim.x >= 256) { if (tid < 128) { sdata[tid] = mySum = mySum + sdata[tid + 128]; } __syncthreads(); }
if (blockDim.x >= 128) { if (tid <  64) { sdata[tid] = mySum = mySum + sdata[tid +  64]; } __syncthreads(); }

// avoid bank conflict
if (tid < 32)
{
// now that we are using warp-synchronous programming (below)
// we need to declare our shared memory volatile so that the compiler
// doesn't reorder stores to it and induce incorrect behavior.
volatile float* smem = sdata;
if (blockDim.x >=  64) { smem[tid] = mySum = mySum + smem[tid + 32]; }
if (blockDim.x >=  32) { smem[tid] = mySum = mySum + smem[tid + 16]; }
if (blockDim.x >=  16) { smem[tid] = mySum = mySum + smem[tid +  8]; }
if (blockDim.x >=   8) { smem[tid] = mySum = mySum + smem[tid +  4]; }
if (blockDim.x >=   4) { smem[tid] = mySum = mySum + smem[tid +  2]; }
if (blockDim.x >=   2) { smem[tid] = mySum = mySum + smem[tid +  1]; }
}

// write result for this block to global mem
if (tid == 0)
g_odata[blockIdx.x] = sdata[0];
}