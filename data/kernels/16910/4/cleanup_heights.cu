#include "includes.h"
const int  Nthreads = 1024, maxFR = 5000, NrankMax = 6;
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
__global__ void	cleanup_heights(const double *Params, const float *x, const int *st, const int *id, int *st1, int *id1, int *counter){

int indx, tid, bid, t, d, Nmax;
volatile __shared__ float s_id[maxFR], s_x[maxFR];
bool flag=0;
float xmax;

tid 		= threadIdx.x;
bid 		= blockIdx.x;

Nmax = min(maxFR, counter[0]);

while (tid<Nmax){
s_x[tid]  = x[tid];
s_id[tid] = id[tid];
tid+=blockDim.x;
}
__syncthreads();

tid = bid*blockDim.x + threadIdx.x;

if (tid<Nmax){
xmax = s_x[tid];
flag = 1;
for (t=0; t<Nmax;t++){
d = abs(s_id[t] - s_id[tid]);
if (d<5 && xmax< s_x[t]){
flag = 0;
break;
}
}
// if flag, then your thread is the max across nearby channels
if(flag){
indx = atomicAdd(&counter[1], 1);
if (indx<maxFR){
st1[indx] = st[tid];
id1[indx] = s_id[tid];
}
}
}

}