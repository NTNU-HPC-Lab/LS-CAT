#include "includes.h"
const int  Nthreads = 1024, maxFR = 100000, NrankMax = 3, nmaxiter = 500, NchanMax = 32;
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

// THIS UPDATE DOES NOT UPDATE ELOSS?
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
__global__ void	cleanup_spikes(const double *Params, const float *data, const float *mu, const float *err, const float *eloss, const int *ftype, int *st, int *id, float *x, float *y,  float *z, int *counter){

int lockout, indx, tid, bid, NT, tid0,  j, id0, t0;
volatile __shared__ float sdata[Nthreads+2*81+1];
bool flag=0;
float err0, Th;

lockout   = (int) Params[4] - 1;
tid 		= threadIdx.x;
bid 		= blockIdx.x;

NT      	=   (int) Params[0];
tid0 		= bid * blockDim.x ;
Th 		= (float) Params[2];
//lam 	    = (float) Params[7];

while(tid0<NT-Nthreads-lockout+1){
if (tid<2*lockout)
sdata[tid] = err[tid0 + tid];
sdata[tid+2*lockout] = err[2*lockout + tid0 + tid];

__syncthreads();

err0 = sdata[tid+lockout];
if(err0>Th*Th){
flag = 0;
for(j=-lockout;j<=lockout;j++)
if(sdata[tid+lockout+j]>err0){
flag = 1;
break;
}
if(flag==0){
indx = atomicAdd(&counter[0], 1);
if (indx<maxFR){
t0        = tid+lockout+tid0;
id0       = ftype[t0];
st[indx] = t0;
id[indx] = id0;
y[indx]  = data[t0 + NT * id0];

//a = 1+ lam;
//b = max(0.0f, data[t0 + NT * id0]) + lam * mu[id0];

x[indx] = sqrt(err0);
//x[indx]  = b/a;    // do I really need this here?
//x[indx]  = y[indx];
z[indx]  = eloss[t0];
}
}
}

tid0 += blockDim.x * gridDim.x;
}
}